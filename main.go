package main

import (
	"encoding/csv"
	"encoding/json"
	"encoding/xml"
	"errors"
	"flag"
	"fmt"
	"os"
	"path"
	"strconv"
	"strings"
	"time"
)

func printUsage() {

	fmt.Println("Usage: map2bbc [flags] <mapfile> <outputfile>")
	fmt.Println("Flags:")
	flag.PrintDefaults()
}

func writePanicHeader(f *os.File) {

	fmt.Fprintln(f, "_effectNone = &00")
	fmt.Fprintln(f, "_effectStars = &10")
	fmt.Fprintln(f, "_effectPaletteChange = &20 ; change to red for hell")
	fmt.Fprintln(f, "_effectPaletteChange2 = &40 ; change to magenta for catacombs area")
	fmt.Fprintln(f, "_effectGems = &80 ; read inv bits, plot red/green boxes for eyes on statues")
	fmt.Fprintln(f, "_effectDark = &08 ; dark unless have torch")
	fmt.Fprintln(f)
	fmt.Fprintln(f, "SCREEN_FLAGS_ITEM_PRESENT = &04")
}

func writePanicFooter(f *os.File) {

	fmt.Fprintln(f, "; These values are per screen and copied into the zp 'snowwindow' memory on a screen change")
	fmt.Fprintln(f, ".snowWindowValueTable:")
	fmt.Fprintln(f, "  EQUB 12,15,26,38 ; in the cave, poor lake, east tower, west tower")
	fmt.Fprintln(f, "  EQUB 0")
	fmt.Fprintln(f)
	fmt.Fprintln(f, ".snowWindowValues:")
	fmt.Fprintln(f, "  EQUB 16*4, 16*0, 16*7, 16*7 ; In the cave")
	fmt.Fprintln(f, "  EQUB 16*4, 16*0, 16*8, 16*5 ; Poor lake")
	fmt.Fprintln(f, "  EQUB 0, 16*0, 16*8, 16*5    ; Top of east tower")
	fmt.Fprintln(f, "  EQUB 0, 0, 128, (16*8)-8    ; Top of west tower")
	fmt.Fprintln(f)
	fmt.Fprintln(f, ".endLevelData:")
	fmt.Fprintln(f, "  PRINT \"Level data takes \", P%-mapData")
}

func exportMap(mapfile string, outfile string, packed bool) error {

	worldPath := path.Dir(mapfile)
	worldBytes, err := os.ReadFile(mapfile)

	if err != nil {

		return err
	}

	var world World
	err = json.Unmarshal(worldBytes, &world)

	if err != nil {

		return err
	}

	if len(world.Maps) == 0 {

		return errors.New("no maps")
	}

	f, err := os.Create(outfile)

	if err != nil {

		return err
	}

	defer f.Close()

	fmt.Fprintln(f, "; Auto-generated by map2bbc on", time.Now().Format("Mon, 2 Jan at 15:04"))
	fmt.Fprintln(f)
	fmt.Fprintln(f, "NUM_SCREENS =", len(world.Maps))

	// If we are writing Mountain Panic packed format, write some header data
	if packed {

		fmt.Fprintln(f)
		writePanicHeader(f)
		fmt.Fprintln(f)
		fmt.Fprintln(f, ".mapData:")
		for i := range len(world.Maps) {

			fmt.Fprintf(f, "  ; Screen %d\n", i)
			fmt.Fprintln(f, "  EQUB &00")
			fmt.Fprintln(f, "  EQUB &00")
			fmt.Fprintln(f, "  EQUB &00")
			fmt.Fprintln(f, "  EQUB &00,&00, &00, &00")
			fmt.Fprintln(f, "  EQUB &00")
		}
		fmt.Fprintln(f)
		fmt.Fprintln(f, ".screenTable:")
		for i := range len(world.Maps) {

			fmt.Fprintf(f, "  EQUW screen%dData\n", i)
		}
		fmt.Fprintln(f)
	}

	// Now loop over the world and write out the level data
	for i, v := range world.Maps {

		mapBytes, err := os.ReadFile(worldPath + "/" + v.Filename)

		if err != nil {

			return err
		}

		var tilemap TileMap
		err = xml.Unmarshal(mapBytes, &tilemap)

		if err != nil {

			return err
		}

		fmt.Fprintf(f, ".screen%dData:\n", i)

		// The CSV reader expects no ',' at the end of a line, so remove those
		trimmed := strings.ReplaceAll(tilemap.Data, ",\n", "\n")
		reader := csv.NewReader(strings.NewReader(trimmed))
		records, err := reader.ReadAll()

		for _, i := range records {

			rowBytes := make([]byte, 0)

			for _, j := range i {

				thisByte, err := strconv.Atoi(j)

				if err != nil {

					return err
				}

				rowBytes = append(rowBytes, byte(thisByte))
			}

			outputStr := "  EQUB "

			if packed {

				packedRowBytes, err := packLine(rowBytes)

				if err != nil {

					return err
				}

				for _, k := range packedRowBytes {

					outputStr += fmt.Sprintf("&%02X,", k)
				}

				outputStr, _ = strings.CutSuffix(outputStr, ",")

			} else {

				for _, k := range rowBytes {

					outputStr += fmt.Sprintf("&%02X", k)
				}

				outputStr, _ = strings.CutSuffix(outputStr, ",")
			}

			fmt.Fprintln(f, outputStr)
		}

		fmt.Fprintln(f)
	}

	if packed {

		writePanicFooter(f)
	}

	return nil
}

func main() {

	packed := flag.Bool("p", false, "Output in Mountain Panic packed format")

	flag.Parse()

	if flag.NArg() != 2 {

		printUsage()
		return
	}

	err := exportMap(flag.Arg(0), flag.Arg(1), *packed)

	if err != nil {

		fmt.Printf("Error exporting: %v\n", err)
	}
}
